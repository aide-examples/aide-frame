<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viewer</title>
    <link rel="stylesheet" href="static/frame/css/base.css">
    <link rel="stylesheet" href="static/frame/css/docs-viewer.css">
</head>
<body>
    <div class="header sticky">
        <h1 id="page-title">Loading...</h1>
        <div style="display: flex; align-items: center; gap: 12px;">
            <span id="gt-container"></span>
            <a href="./" class="header-btn" id="back-link">Back</a>
        </div>
    </div>

    <div class="docs-layout">
        <nav class="docs-sidebar" id="sidebar">
            <p style="color: #666; font-size: 0.9rem;">Loading navigation...</p>
        </nav>

        <main class="docs-content">
            <div id="breadcrumb" class="breadcrumb"></div>
            <div id="content" class="content-loading">Loading...</div>
        </main>
    </div>

    <button class="sidebar-toggle" onclick="document.getElementById('sidebar').classList.toggle('open')">
        ☰
    </button>

    <!-- Editor Modal -->
    <div id="editor-modal" class="editor-modal" style="display: none;">
        <div class="editor-modal-content">
            <div class="editor-header">
                <span id="editor-title">Edit Section</span>
                <button class="editor-close" onclick="closeEditor()">&times;</button>
            </div>
            <div id="editor-container" class="editor-container">
                <textarea id="editor-textarea" class="editor-textarea" spellcheck="false"></textarea>
                <div id="editor-highlight" class="editor-highlight"></div>
            </div>
            <div class="editor-footer">
                <button class="editor-btn editor-btn-cancel" onclick="closeEditor()">Cancel</button>
                <button class="editor-btn editor-btn-save" onclick="saveSection()">Save</button>
            </div>
        </div>
    </div>

    <script src="static/frame/vendor/marked/marked.min.js"></script>
    <script src="static/frame/vendor/polyglot/polyglot.min.js"></script>
    <script src="static/frame/js/i18n.js"></script>
    <script src="static/frame/js/google-translate.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js" onerror="window.MERMAID_FAILED=true"></script>
    <script>
        // Determine root from URL path
        // Standard roots: /about -> docs, /help -> help
        // Custom roots: /<name> -> name (e.g., /samples -> samples)
        // Strip basePath prefix (from <base> tag or app config) for route detection
        const baseEl = document.querySelector('base');
        const _basePath = baseEl ? new URL(baseEl.href).pathname.replace(/\/$/, '') : '';
        const pathname = window.location.pathname.replace(_basePath, '').replace(/\.html$/, '');
        let viewerRoot, titleSuffix, assetPrefix;

        if (pathname === '/about' || pathname.startsWith('/about/')) {
            viewerRoot = 'docs';
            titleSuffix = null;  // Will be set after i18n init
            assetPrefix = 'docs-assets/';
        } else if (pathname === '/help' || pathname.startsWith('/help/')) {
            viewerRoot = 'help';
            titleSuffix = null;
            assetPrefix = 'help-assets/';
        } else {
            // Custom root - extract name from path (e.g., /samples -> samples)
            viewerRoot = pathname.substring(1).split('/')[0];
            titleSuffix = null;
            assetPrefix = viewerRoot + '-assets/';
        }

        // App configuration (loaded from API)
        let appConfig = {
            app_name: 'App',
            back_link: '/',
            back_text: 'Back',
            features: { mermaid: true },
            editable: { docs: false, help: false }
        };

        // Current document state for editing
        let currentDocPath = null;
        let currentMarkdown = null;
        let editingSection = null;  // { start, end, headingText, headingLevel }

        // Document names for cross-reference hooks (built from navigation structure)
        let docNamesList = null;  // [{name, path}] sorted by name length desc

        // =============================================================================
        // EDITOR FUNCTIONS
        // =============================================================================

        /**
         * Check if current root is editable
         */
        function isCurrentRootEditable() {
            if (viewerRoot === 'docs') return appConfig.editable?.docs === true;
            if (viewerRoot === 'help') return appConfig.editable?.help === true;
            if (appConfig.custom_roots && appConfig.custom_roots[viewerRoot]) {
                return appConfig.custom_roots[viewerRoot].editable === true;
            }
            return false;
        }

        /**
         * Extract a section from markdown starting at a heading.
         * Returns { start, end, content } where start/end are character indices.
         */
        function extractSection(markdown, headingText, headingLevel) {
            const lines = markdown.split('\n');
            const prefix = '#'.repeat(headingLevel) + ' ';
            let start = -1;
            let end = markdown.length;
            let charPos = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineStart = charPos;
                charPos += line.length + 1; // +1 for newline

                // Find start: match heading level and text
                if (start === -1) {
                    if (line.startsWith(prefix) && line.substring(prefix.length).trim() === headingText.trim()) {
                        start = lineStart;
                    }
                    continue;
                }

                // Find end: next heading of same or higher level
                if (line.match(/^#{1,6} /)) {
                    const matchLevel = line.match(/^(#+)/)[1].length;
                    if (matchLevel <= headingLevel) {
                        end = lineStart;
                        break;
                    }
                }
            }

            if (start === -1) return null;

            return {
                start,
                end,
                content: markdown.substring(start, end)
            };
        }

        /**
         * Replace a section in the markdown.
         */
        function replaceSection(markdown, start, end, newContent) {
            return markdown.substring(0, start) + newContent + markdown.substring(end);
        }

        /**
         * Apply simple CSS-based syntax highlighting to markdown.
         */
        function highlightMarkdown(text) {
            // Escape HTML
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // Highlight patterns (order matters)
            html = html
                // Headers
                .replace(/^(#{1,6} .*)$/gm, '<span class="md-heading">$1</span>')
                // Bold
                .replace(/(\*\*[^*]+\*\*)/g, '<span class="md-bold">$1</span>')
                // Italic
                .replace(/(\*[^*]+\*)/g, '<span class="md-italic">$1</span>')
                // Code inline
                .replace(/(`[^`]+`)/g, '<span class="md-code">$1</span>')
                // Links
                .replace(/(\[[^\]]+\]\([^)]+\))/g, '<span class="md-link">$1</span>')
                // Lists
                .replace(/^(\s*[-*+] )/gm, '<span class="md-list">$1</span>')
                .replace(/^(\s*\d+\. )/gm, '<span class="md-list">$1</span>');

            return html;
        }

        /**
         * Update the highlight overlay to match textarea content.
         */
        function updateHighlight() {
            const textarea = document.getElementById('editor-textarea');
            const highlight = document.getElementById('editor-highlight');
            highlight.innerHTML = highlightMarkdown(textarea.value) + '\n';
        }

        /**
         * Open editor for a section.
         */
        function openEditor(headingText, headingLevel) {
            if (!currentMarkdown) return;

            const section = extractSection(currentMarkdown, headingText, headingLevel);
            if (!section) {
                console.error('Could not find section:', headingText);
                return;
            }

            editingSection = {
                start: section.start,
                end: section.end,
                headingText,
                headingLevel
            };

            document.getElementById('editor-title').textContent = 'Edit: ' + headingText;
            const textarea = document.getElementById('editor-textarea');
            textarea.value = section.content;
            updateHighlight();

            document.getElementById('editor-modal').style.display = 'flex';
            textarea.focus();
        }

        /**
         * Close the editor without saving.
         */
        function closeEditor() {
            document.getElementById('editor-modal').style.display = 'none';
            editingSection = null;
        }

        // Heading to scroll to after reload
        let scrollToHeadingText = null;

        /**
         * Save the edited section.
         */
        async function saveSection() {
            if (!editingSection || !currentDocPath) return;

            const textarea = document.getElementById('editor-textarea');
            let newContent = textarea.value;

            // Ensure section ends with newline
            if (!newContent.endsWith('\n')) {
                newContent += '\n';
            }

            // Extract the new heading text from edited content (first line)
            const firstLine = newContent.split('\n')[0];
            const headingMatch = firstLine.match(/^#+\s+(.+)$/);
            scrollToHeadingText = headingMatch ? headingMatch[1].trim() : editingSection.headingText;

            const newMarkdown = replaceSection(
                currentMarkdown,
                editingSection.start,
                editingSection.end,
                newContent
            );

            try {
                const res = await fetch('api/viewer/content', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        root: viewerRoot,
                        path: currentDocPath,
                        content: newMarkdown
                    })
                });

                const data = await res.json();
                if (data.error) throw new Error(data.error);

                closeEditor();
                // Reload the document to show changes
                loadDoc(currentDocPath);

            } catch (e) {
                alert('Error saving: ' + e.message);
            }
        }

        /**
         * Handle right-click on headings.
         */
        function handleHeadingRightClick(e) {
            if (!isCurrentRootEditable()) return;

            e.preventDefault();
            const heading = e.target.closest('h1, h2, h3, h4, h5, h6');
            if (!heading) return;

            // Don't edit framework docs
            if (currentDocPath && currentDocPath.startsWith('framework/')) return;

            const headingText = heading.textContent;
            const headingLevel = parseInt(heading.tagName.substring(1));

            openEditor(headingText, headingLevel);
        }

        // Initialize mermaid if available
        if (typeof mermaid !== 'undefined' && !window.MERMAID_FAILED) {
            mermaid.initialize({
                startOnLoad: false,
                theme: 'default',
                securityLevel: 'loose',
                flowchart: { useMaxWidth: true, htmlLabels: true }
            });
        }

        // Custom renderer for mermaid code blocks
        const renderer = new marked.Renderer();
        const originalCodeRenderer = renderer.code.bind(renderer);

        renderer.code = function(code, language) {
            const codeText = typeof code === 'object' ? code.text : code;
            const codeLang = typeof code === 'object' ? code.lang : language;
            if (codeLang === 'mermaid' && typeof mermaid !== 'undefined' && !window.MERMAID_FAILED) {
                return '<div class="mermaid">' + codeText + '</div>';
            }
            return originalCodeRenderer(code, language);
        };

        marked.setOptions({ renderer: renderer, gfm: true, breaks: false });

        // Load app configuration
        async function loadAppConfig() {
            try {
                const res = await fetch('api/app/config');
                if (res.ok) {
                    appConfig = await res.json();
                    // Get title from custom_roots if available, otherwise from i18n
                    if (appConfig.custom_roots && appConfig.custom_roots[viewerRoot]) {
                        titleSuffix = appConfig.custom_roots[viewerRoot].title;
                    } else if (viewerRoot === 'docs') {
                        titleSuffix = i18n.t('documentation');
                    } else if (viewerRoot === 'help') {
                        titleSuffix = i18n.t('help');
                    } else {
                        titleSuffix = viewerRoot.charAt(0).toUpperCase() + viewerRoot.slice(1);
                    }
                    // Update page elements
                    document.getElementById('page-title').textContent = appConfig.app_name + ' - ' + titleSuffix;
                    document.title = titleSuffix + ' - ' + appConfig.app_name;
                    document.getElementById('back-link').href = appConfig.back_link;
                    document.getElementById('back-link').textContent = i18n.t('back');

                    // Load viewer hooks script if configured
                    if (appConfig.viewer_hooks) {
                        await new Promise((resolve) => {
                            const script = document.createElement('script');
                            script.src = appConfig.viewer_hooks;
                            script.onload = resolve;
                            script.onerror = resolve;  // Optional — don't fail if missing
                            document.head.appendChild(script);
                        });
                    }
                }
            } catch (e) {
                console.warn('Could not load app config:', e);
            }
        }

        // Generate Table of Contents
        function generateTOC(container) {
            const headings = container.querySelectorAll('h1, h2, h3, h4');
            if (headings.length === 0) return null;

            const contentHeadings = Array.from(headings).filter(h => !h.closest('.toc-container'));
            if (contentHeadings.length <= 3) return null;

            const tocItems = [];
            const usedIds = new Set();
            contentHeadings.forEach((heading, index) => {
                const text = heading.textContent;
                let slug = text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-+|-+$/g, '');
                // Use slug as ID, append index only if duplicate
                let id = slug || 'heading';
                if (usedIds.has(id)) {
                    id = id + '-' + index;
                }
                usedIds.add(id);
                heading.setAttribute('id', id);
                tocItems.push({ text, id, level: heading.tagName.toLowerCase() });
            });

            let tocHtml = '<ul>';
            tocItems.forEach(item => {
                const escapedText = item.text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                tocHtml += `<li><a href="#${item.id}" class="toc-${item.level}">${escapedText}</a></li>`;
            });
            tocHtml += '</ul>';

            const tocContainer = document.createElement('div');
            tocContainer.className = 'toc-container';
            tocContainer.innerHTML = `
                <div class="toc-header" onclick="this.parentElement.classList.toggle('collapsed')">
                    <span class="toc-title">${i18n.t('toc')}</span>
                    <span class="toc-toggle">▼</span>
                </div>
                <div class="toc-content">${tocHtml}</div>
            `;

            tocContainer.querySelectorAll('a[href^="#"]').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        history.pushState(null, '', link.getAttribute('href'));
                    }
                });
            });

            return tocContainer;
        }

        // Update breadcrumb
        function updateBreadcrumb(docPath) {
            const breadcrumb = document.getElementById('breadcrumb');
            if (!docPath || docPath === 'index.md') {
                breadcrumb.innerHTML = '';
                return;
            }

            const parts = docPath.replace('.md', '').split('/');
            // Determine route path for breadcrumb links (relative)
            const routePath = viewerRoot === 'docs' ? 'about' : viewerRoot === 'help' ? 'help' : viewerRoot;
            let html = `<a href="${routePath}?doc=index.md">${titleSuffix}</a>`;

            parts.forEach((part, i) => {
                html += '<span>/</span>';
                const name = part.charAt(0).toUpperCase() + part.slice(1).replace(/-/g, ' ');
                if (i === parts.length - 1) {
                    html += name;
                } else {
                    html += `<a href="${routePath}?doc=${parts.slice(0, i+1).join('/')}/index.md">${name}</a>`;
                }
            });
            breadcrumb.innerHTML = html;
        }

        // Update active sidebar link
        function updateActiveLink(docPath) {
            document.querySelectorAll('.docs-sidebar a').forEach(a => {
                a.classList.toggle('active', a.dataset.doc === docPath);
            });
        }

        // Load documentation
        // @param {string} docPath - Path to the document
        // @param {string} anchor - Optional anchor to scroll to (e.g., '#section-name')
        async function loadDoc(docPath, anchor = '') {
            const container = document.getElementById('content');
            container.className = 'content-loading';
            container.innerHTML = i18n.t('loading');

            try {
                let data;
                const apiPath = docPath || 'index.md';

                const res = await fetch(`api/viewer/content?root=${viewerRoot}&path=${encodeURIComponent(apiPath)}`);
                data = await res.json();
                if (data.error) throw new Error(data.error);
                docPath = apiPath;

                // Store for editing
                currentDocPath = docPath;
                currentMarkdown = data.content;

                container.className = 'markdown-body';
                container.innerHTML = marked.parse(data.content);

                // Rewrite image URLs
                const currentDir = docPath.includes('/') ? docPath.substring(0, docPath.lastIndexOf('/')) : '';
                container.querySelectorAll('img').forEach(img => {
                    const src = img.getAttribute('src');
                    if (src.startsWith('http://') || src.startsWith('https://') || src.startsWith('/')) return;
                    const fullPath = currentDir ? currentDir + '/' + src : src;
                    img.setAttribute('src', assetPrefix + fullPath);
                });

                // Generate TOC
                const toc = generateTOC(container);
                if (toc) container.insertBefore(toc, container.firstChild);

                // Render mermaid diagrams
                if (typeof mermaid !== 'undefined' && !window.MERMAID_FAILED && appConfig.features.mermaid) {
                    await mermaid.run({ nodes: document.querySelectorAll('.mermaid') });
                }

                // Intercept .md links (including those with anchors like file.md#section)
                container.querySelectorAll('a[href*=".md"]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        let href = link.getAttribute('href');
                        if (href.startsWith('http://') || href.startsWith('https://')) return;
                        e.preventDefault();

                        // Extract anchor if present
                        let anchor = '';
                        if (href.includes('#')) {
                            const hashIdx = href.indexOf('#');
                            anchor = href.substring(hashIdx);
                            href = href.substring(0, hashIdx);
                        }

                        let targetDoc = href;
                        if (!href.startsWith('/') && docPath && docPath.includes('/')) {
                            const currentDir = docPath.substring(0, docPath.lastIndexOf('/'));
                            targetDoc = currentDir + '/' + href;
                        }
                        const parts = targetDoc.split('/');
                        const normalized = [];
                        for (const part of parts) {
                            if (part === '..') normalized.pop();
                            else if (part !== '.') normalized.push(part);
                        }
                        loadDoc(normalized.join('/'), anchor);
                    });
                });

                // Post-processing hook (app-specific content enhancement, may be async)
                if (typeof window.viewerContentHook === 'function') {
                    await window.viewerContentHook(container, {
                        docPath,
                        viewerRoot,
                        docNames: docNamesList || []
                    });
                }

                // Add right-click handler on headings for editing
                if (isCurrentRootEditable() && !docPath.startsWith('framework/')) {
                    container.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
                        // Skip TOC headings
                        if (heading.closest('.toc-container')) return;
                        heading.style.cursor = 'context-menu';
                        heading.addEventListener('contextmenu', handleHeadingRightClick);
                    });
                }

                updateBreadcrumb(docPath);
                updateActiveLink(docPath);

                const newUrl = '?doc=' + docPath;
                if (window.location.search !== newUrl) {
                    history.pushState({doc: docPath}, '', newUrl);
                }

                document.getElementById('sidebar').classList.remove('open');

                // Scroll to anchor, edited heading, or top
                if (anchor) {
                    // Scroll to anchor (e.g., #section-name)
                    const anchorId = anchor.startsWith('#') ? anchor.substring(1) : anchor;
                    let targetElement = document.getElementById(anchorId);

                    // If exact match not found, search for duplicate-suffixed IDs (e.g., operationalstatus-6)
                    if (!targetElement) {
                        const allElements = document.querySelectorAll('[id]');
                        for (const el of allElements) {
                            if (el.id === anchorId || el.id.startsWith(anchorId + '-')) {
                                targetElement = el;
                                break;
                            }
                        }
                    }

                    if (targetElement) {
                        const headerHeight = 70; // Account for sticky header
                        const elementTop = targetElement.getBoundingClientRect().top + window.pageYOffset;
                        window.scrollTo({ top: elementTop - headerHeight, behavior: 'smooth' });
                    } else {
                        window.scrollTo(0, 0);
                    }
                } else if (scrollToHeadingText) {
                    const headings = container.querySelectorAll('h1, h2, h3, h4, h5, h6');
                    for (const h of headings) {
                        if (h.textContent.trim() === scrollToHeadingText) {
                            // Scroll with offset from top
                            const headerHeight = 70; // Account for sticky header
                            const elementTop = h.getBoundingClientRect().top + window.pageYOffset;
                            window.scrollTo({ top: elementTop - headerHeight, behavior: 'smooth' });
                            scrollToHeadingText = null;
                            break;
                        }
                    }
                    if (scrollToHeadingText) {
                        // Heading not found (maybe renamed), scroll to top
                        window.scrollTo(0, 0);
                        scrollToHeadingText = null;
                    }
                } else {
                    window.scrollTo(0, 0);
                }

            } catch (e) {
                container.className = 'markdown-body';
                container.innerHTML = '<p style="color: #dc2626;">' + i18n.t('error_loading') + ': ' + e.message + '</p>';
            }
        }

        // Build navbar from API
        async function buildNavbar() {
            const sidebar = document.getElementById('sidebar');
            try {
                const res = await fetch(`api/viewer/structure?root=${viewerRoot}`);
                const data = await res.json();

                let html = '';

                // Handle flat structure (files array) vs sectioned structure (sections array)
                if (data.files && !data.sections) {
                    // Flat structure - just list files
                    html += '<ul>';
                    for (const doc of data.files) {
                        html += `<li><a href="?doc=${doc.path}" data-doc="${doc.path}">${doc.title}</a></li>`;
                    }
                    html += '</ul>';
                } else if (data.sections) {
                    // Sectioned structure
                    for (const section of data.sections) {
                        // Only show section header if there are multiple sections or name differs from titleSuffix
                        const showHeader = data.sections.length > 1 || section.name !== titleSuffix;
                        // Framework section is collapsed by default
                        // Section may have 'docs' (Python) or 'files' (Node.js) array
                        const sectionDocs = section.docs || section.files || [];
                        const isFramework = sectionDocs.some(d => d.framework);
                        if (showHeader) {
                            html += `<div class="section${isFramework ? ' collapsed' : ''}">`;
                            html += `<h3 onclick="this.parentElement.classList.toggle('collapsed')"><span class="section-toggle">▼</span>${section.name}</h3>`;
                        }
                        html += '<ul>';
                        for (const doc of sectionDocs) {
                            const titleAttr = doc.description
                                ? ` title="${doc.description.replace(/"/g, '&quot;')}"`
                                : '';
                            const docPath = doc.framework ? 'framework/' + doc.path : doc.path;
                            html += `<li><a href="?doc=${docPath}" data-doc="${docPath}"${titleAttr}>${doc.title}</a></li>`;
                        }
                        html += '</ul>';
                        if (showHeader) {
                            html += `</div>`;
                        }
                    }
                }

                sidebar.innerHTML = html;

                // Collect document names for content hook cross-referencing
                docNamesList = [];
                const collectDocName = (doc, isFramework) => {
                    const p = isFramework ? 'framework/' + doc.path : doc.path;
                    const name = doc.path.replace('.md', '').split('/').pop();
                    if (name !== 'index') {
                        docNamesList.push({ name, path: p });
                    }
                };
                if (data.files && !data.sections) {
                    data.files.forEach(d => collectDocName(d, false));
                } else if (data.sections) {
                    for (const section of data.sections) {
                        (section.docs || section.files || []).forEach(d => collectDocName(d, d.framework));
                    }
                }
                docNamesList.sort((a, b) => b.name.length - a.name.length);

                sidebar.querySelectorAll('a').forEach(a => {
                    a.addEventListener('click', (e) => {
                        e.preventDefault();
                        loadDoc(a.dataset.doc);
                    });
                });

                const urlParams = new URLSearchParams(window.location.search);
                const currentDoc = urlParams.get('doc') || 'index.md';
                updateActiveLink(currentDoc);

            } catch (e) {
                sidebar.innerHTML = '<p style="color: #dc2626;">' + i18n.t('nav_error') + '</p>';
                console.error('Failed to load navbar:', e);
            }
        }

        // Handle browser back/forward
        window.addEventListener('popstate', (e) => {
            const doc = e.state?.doc || new URLSearchParams(window.location.search).get('doc');
            loadDoc(doc);
        });

        // Initialize
        async function init() {
            await i18n.init();  // Load translations first
            await loadAppConfig();
            await buildNavbar();
            const urlParams = new URLSearchParams(window.location.search);
            const initialDoc = urlParams.get('doc');
            loadDoc(initialDoc);

            // Initialize Google Translate for docs viewer
            GoogleTranslate.init('#gt-container');

            // Setup editor textarea sync for highlighting
            const editorTextarea = document.getElementById('editor-textarea');
            if (editorTextarea) {
                editorTextarea.addEventListener('input', updateHighlight);
                editorTextarea.addEventListener('scroll', () => {
                    const highlight = document.getElementById('editor-highlight');
                    highlight.scrollTop = editorTextarea.scrollTop;
                    highlight.scrollLeft = editorTextarea.scrollLeft;
                });
            }
        }
        init();
    </script>
</body>
</html>
